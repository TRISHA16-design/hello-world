# -*- coding: utf-8 -*-
"""streamlit_app.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rHR-b2MOgyIQWyaS9B8a-vc8BCx5G6_A
"""

# streamlit_app.py
import streamlit as st
import recommender_logic # This imports your recommender_logic.py and should trigger load_artifacts()

# --- Streamlit UI Configuration ---
st.set_page_config(
    page_title="Movie Recommender",
    page_icon="üé¨",
    layout="wide",
    initial_sidebar_state="expanded"
)

# --- Main Application UI ---
st.title("üé¨ Movie Recommender Engine")
st.markdown(
    "Discover movies similar to your favorites! "
    "Enter a movie title below and get recommendations based on content similarity "
    "(like genres, plot summaries, cast, and directors)."
)
st.markdown("---") # Visual separator

# Check if artifacts were loaded successfully by recommender_logic on import
if recommender_logic.artifacts_error:
    st.error(
        f"Failed to load recommender model artifacts: {recommender_logic.artifacts_error}\n"
        "Please ensure you have run `preprocess_data.py` and the artifact files "
        "(`cosine_sim_matrix.npy`, `movies_df_indexed.parquet`, `title_to_indices.joblib`) "
        "are in the same directory as the Streamlit app."
    )
    st.stop() # Stop the app if artifacts can't be loaded
elif not recommender_logic.artifacts_loaded:
    # This case should ideally be caught by artifacts_error, but as a fallback:
    st.error(
        "Recommender model artifacts are not loaded. The application might not work correctly. "
        "Please check the console for errors."
    )
    st.stop()

# --- User Input Section ---
col1, col2 = st.columns([3, 1]) # Create two columns for input and slider

with col1:
    movie_title_input = st.text_input(
        "Enter a movie title:",
        placeholder="e.g., The Matrix, Toy Story, Inception",
        help="Type the full or partial name of a movie you like."
    )

with col2:
    num_recs = st.slider(
        "Number of recommendations:",
        min_value=3,
        max_value=15,
        value=5,
        help="Choose how many recommendations you want to see."
    )

# --- Recommendation Button and Display ---
if st.button("‚ú® Get Recommendations", type="primary", use_container_width=True):
    if movie_title_input:
        with st.spinner(f"Finding recommendations for '{movie_title_input}'..."):
            recommendations = recommender_logic.recommend(movie_title_input, num_recommendations=num_recs)

        st.markdown("---") # Separator
        if isinstance(recommendations, str): # It's an error message or info string
            st.error(recommendations)
        elif recommendations:
            st.success(f"Here are {len(recommendations)} movies similar to '{movie_title_input}':")

            # Display recommendations in a more structured way
            for i, rec in enumerate(recommendations):
                st.markdown(f"**{i+1}.** {rec}")

            # You could add more details if your movies_df_indexed stored them, e.g.,
            # rec_title = rec.split(" (Similarity:")[0]
            # movie_details = recommender_logic.movies_df_indexed[recommender_logic.movies_df_indexed['title'] == rec_title].iloc[0]
            # st.markdown(f"**{i+1}. {movie_details['title']}** (Genre: {movie_details.get('genres','N/A')}) - Similarity: ...")

        else: # Should be caught by "No similar..." but as a fallback
            st.warning(f"Sorry, we couldn't find any recommendations for '{movie_title_input}'. Try a different movie.")
    else:
        st.warning("Oops! Please enter a movie title to get recommendations.")

# --- Sidebar Information ---
st.sidebar.header("‚ÑπÔ∏è About This App")
st.sidebar.info(
    "This Movie Recommender uses a content-based filtering approach. "
    "It analyzes movie features like genre, plot, director, and cast "
    "to find movies with similar characteristics."
)
st.sidebar.markdown("---")
st.sidebar.subheader("How it works:")
st.sidebar.markdown(
    """
    1.  **Data Preprocessing**: Movie data is cleaned, and key textual features are combined.
    2.  **TF-IDF Vectorization**: Text features are converted into numerical vectors.
    3.  **Cosine Similarity**: The similarity between all pairs of movies is calculated based on their vectors.
    4.  **Recommendation**: When you enter a movie, the app finds the most similar movies from the precomputed matrix.
    """
)
st.sidebar.markdown("---")
st.sidebar.markdown("Built with [Streamlit](https://streamlit.io).")