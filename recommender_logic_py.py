# -*- coding: utf-8 -*-
"""recommender_logic.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vGPzMk9OFcuTbBd1xECDMBchflXI2Zlb
"""

# recommender_logic.py
import pandas as pd
import numpy as np
import joblib
from typing import List, Union
import os

# --- Global Variables to hold loaded models/data ---
cosine_sim_matrix = None
movies_df_indexed = None
title_to_indices = None
artifacts_loaded = False
artifacts_error = None # To store any error message during loading

def load_artifacts():
    """Loads the precomputed artifacts."""
    global cosine_sim_matrix, movies_df_indexed, title_to_indices, artifacts_loaded, artifacts_error

    # This function should only attempt to load once.
    if artifacts_loaded or artifacts_error:
        return

    print("Attempting to load precomputed artifacts for recommender...")
    try:
        # Construct paths relative to this script file if needed,
        # but for Streamlit deployment, keeping them in the root is simplest.
        cosine_sim_matrix_path = 'cosine_sim_matrix.npy'
        movies_df_indexed_path = 'movies_df_indexed.parquet'
        title_to_indices_path = 'title_to_indices.joblib'

        if not all(os.path.exists(p) for p in [cosine_sim_matrix_path, movies_df_indexed_path, title_to_indices_path]):
            error_msg = "One or more artifact files are missing. Please run preprocess_data.py first."
            print(f"Error: {error_msg}")
            artifacts_error = error_msg
            return

        cosine_sim_matrix = np.load(cosine_sim_matrix_path)
        movies_df_indexed = pd.read_parquet(movies_df_indexed_path)
        title_to_indices = joblib.load(title_to_indices_path)

        artifacts_loaded = True
        print("Artifacts loaded successfully.")
    except FileNotFoundError as e:
        error_msg = f"Error loading artifacts: {e}. Make sure 'preprocess_data.py' has been run and artifacts are in the root directory."
        print(error_msg)
        artifacts_error = error_msg
    except Exception as e:
        error_msg = f"An unexpected error occurred during artifact loading: {e}"
        print(error_msg)
        artifacts_error = error_msg


def recommend(movie_title_input: str, num_recommendations: int = 5) -> Union[List[str], str]:
    """
    Generates movie recommendations.
    """
    global title_to_indices, cosine_sim_matrix, movies_df_indexed, artifacts_loaded, artifacts_error

    if artifacts_error: # If loading failed
        return artifacts_error
    if not artifacts_loaded:
        # Attempt to load if not already loaded (e.g., if app starts and recommend is called before load_artifacts)
        # This is a fallback, Streamlit app should ideally call load_artifacts at the start.
        load_artifacts()
        if artifacts_error: return artifacts_error # Check again after trying to load
        if not artifacts_loaded: return "Recommender system is not initialized. Artifacts could not be loaded."

    if not movie_title_input:
        return "Please enter a movie title."

    current_movie_title = movie_title_input.strip() # Clean input

    # Case-insensitive search and partial match handling
    if current_movie_title not in title_to_indices:
        # Try exact match ignoring case first
        exact_case_insensitive_match = title_to_indices.index[title_to_indices.index.str.lower() == current_movie_title.lower()]
        if not exact_case_insensitive_match.empty:
            current_movie_title = exact_case_insensitive_match[0]
            # print(f"Using case-insensitive match: '{current_movie_title}'")
        else:
            # Try partial match (contains)
            possible_matches = movies_df_indexed[movies_df_indexed['title'].str.contains(current_movie_title, case=False, na=False)]
            if not possible_matches.empty:
                actual_title = possible_matches['title'].iloc[0]
                # print(f"Input '{movie_title_input}' not found directly. Using closest match: '{actual_title}'.")
                current_movie_title = actual_title
            else:
                return f"Movie '{movie_title_input}' not found in the dataset. Please try a different title or check spelling."

    # Final check if the (potentially corrected) title is in our index
    if current_movie_title not in title_to_indices:
         return f"Movie '{current_movie_title}' (derived from '{movie_title_input}') still not found. Please try another title."

    movie_idx = title_to_indices[current_movie_title]

    # If title_to_indices somehow maps to a Series (e.g. if title wasn't unique and not handled in preprocessing)
    if isinstance(movie_idx, pd.Series):
        movie_idx = movie_idx.iloc[0] # Take the first index

    if movie_idx >= cosine_sim_matrix.shape[0]:
        return f"Error: Movie index {movie_idx} is out of bounds for similarity matrix (size: {cosine_sim_matrix.shape[0]}). This indicates a mismatch in saved artifacts."

    # Get similarity scores for the movie
    sim_scores = list(enumerate(cosine_sim_matrix[movie_idx]))
    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)

    # Get top N recommendations (excluding the movie itself, which is sim_scores[0])
    sim_scores = sim_scores[1 : num_recommendations + 1]

    recommendations = []
    for i_score, sim_score_val in sim_scores:
        if i_score >= len(movies_df_indexed):
            print(f"Warning: Recommended index {i_score} is out of bounds for DataFrame. Skipping.")
            continue

        # Get the title from movies_df_indexed using the index from sim_scores
        title = movies_df_indexed['title'].iloc[i_score]
        recommendations.append(f"{title} (Similarity: {sim_score_val:.2f})")

    return recommendations if recommendations else "No similar recommendations found for this movie."

# Call load_artifacts when this module is imported.
# This ensures that artifacts are loaded (or attempted to be loaded)
# as soon as the Streamlit app imports this logic.
if not artifacts_loaded and not artifacts_error:
    load_artifacts()